type Query {findWorkflow(id:ID!):Workflow
findWorkflowList( page: PageInput, sort:SortInput,filters:[FilterInput]):WorkflowConnection
findAddress(id:ID!):Address
findAddressList( page: PageInput, sort:SortInput,filters:[FilterInput]):AddressConnection
findProductFunction(id:ID!):ProductFunction
findProductFunctionList( page: PageInput, sort:SortInput,filters:[FilterInput]):ProductFunctionConnection
findAlert(id:ID!):Alert
findAlertList( page: PageInput, sort:SortInput,filters:[FilterInput]):AlertConnection
findAlertRule(id:ID!):AlertRule
findAlertRuleList( page: PageInput, sort:SortInput,filters:[FilterInput]):AlertRuleConnection
findAttributes(id:ID!):Attributes
findAttributesList( page: PageInput, sort:SortInput,filters:[FilterInput]):AttributesConnection
findAuditLogs(id:ID!):AuditLogs
findAuditLogsList( page: PageInput, sort:SortInput,filters:[FilterInput]):AuditLogsConnection
findCfType(id:ID!):CfType
findCfTypeList( page: PageInput, sort:SortInput,filters:[FilterInput]):CfTypeConnection
findCfValue(id:ID!):CfValue
findCfValueList( page: PageInput, sort:SortInput,filters:[FilterInput]):CfValueConnection
findDomain(id:ID!):Domain
findDomainList( page: PageInput, sort:SortInput,filters:[FilterInput]):DomainConnection
findCustomer(id:ID!):Customer
findCustomerList( page: PageInput, sort:SortInput,filters:[FilterInput]):CustomerConnection
findDelegation(id:ID!):Delegation
findDelegationList( page: PageInput, sort:SortInput,filters:[FilterInput]):DelegationConnection
findEmailTemplate(id:ID!):EmailTemplate
findEmailTemplateList( page: PageInput, sort:SortInput,filters:[FilterInput]):EmailTemplateConnection
findEntityReference(id:ID!):EntityReference
findEntityReferenceList( page: PageInput, sort:SortInput,filters:[FilterInput]):EntityReferenceConnection
findEvent(id:ID!):Event
findEventList( page: PageInput, sort:SortInput,filters:[FilterInput]):EventConnection
findFormulaType(id:ID!):FormulaType
findFormulaTypeList( page: PageInput, sort:SortInput,filters:[FilterInput]):FormulaTypeConnection
findHtmlTag(id:ID!):HtmlTag
findHtmlTagList( page: PageInput, sort:SortInput,filters:[FilterInput]):HtmlTagConnection
findWfInstance(id:ID!):WfInstance
findWfInstanceList( page: PageInput, sort:SortInput,filters:[FilterInput]):WfInstanceConnection
findInstance(id:ID!):Instance
findInstanceList( page: PageInput, sort:SortInput,filters:[FilterInput]):InstanceConnection
findLanguage(id:ID!):Language
findLanguageList( page: PageInput, sort:SortInput,filters:[FilterInput]):LanguageConnection
findMessage(id:ID!):Message
findMessageList( page: PageInput, sort:SortInput,filters:[FilterInput]):MessageConnection
findProduct(id:ID!):Product
findProductList( page: PageInput, sort:SortInput,filters:[FilterInput]):ProductConnection
findNode(id:ID!):Node
findNodeList( page: PageInput, sort:SortInput,filters:[FilterInput]):NodeConnection
findNodeCf(id:ID!):NodeCf
findNodeCfList( page: PageInput, sort:SortInput,filters:[FilterInput]):NodeCfConnection
findNumberSequenceRule(id:ID!):NumberSequenceRule
findNumberSequenceRuleList( page: PageInput, sort:SortInput,filters:[FilterInput]):NumberSequenceRuleConnection
findNumberSequenceRuleSegment(id:ID!):NumberSequenceRuleSegment
findNumberSequenceRuleSegmentList( page: PageInput, sort:SortInput,filters:[FilterInput]):NumberSequenceRuleSegmentConnection
findOrganization(id:ID!):Organization
findOrganizationList( page: PageInput, sort:SortInput,filters:[FilterInput]):OrganizationConnection
findPerson(id:ID!):Person
findPersonList( page: PageInput, sort:SortInput,filters:[FilterInput]):PersonConnection
findPersonStatus(id:ID!):PersonStatus
findPersonStatusList( page: PageInput, sort:SortInput,filters:[FilterInput]):PersonStatusConnection
findPhase(id:ID!):Phase
findPhaseList( page: PageInput, sort:SortInput,filters:[FilterInput]):PhaseConnection
findPreference(id:ID!):Preference
findPreferenceList( page: PageInput, sort:SortInput,filters:[FilterInput]):PreferenceConnection
findProcess(id:ID!):Process
findProcessList( page: PageInput, sort:SortInput,filters:[FilterInput]):ProcessConnection
findRequest(id:ID!):Request
findRequestList( page: PageInput, sort:SortInput,filters:[FilterInput]):RequestConnection
findRole(id:ID!):Role
findRoleList( page: PageInput, sort:SortInput,filters:[FilterInput]):RoleConnection
findSegment(id:ID!):Segment
findSegmentList( page: PageInput, sort:SortInput,filters:[FilterInput]):SegmentConnection
findStage(id:ID!):Stage
findStageList( page: PageInput, sort:SortInput,filters:[FilterInput]):StageConnection
findStatus(id:ID!):Status
findStatusList( page: PageInput, sort:SortInput,filters:[FilterInput]):StatusConnection
findStatusType(id:ID!):StatusType
findStatusTypeList( page: PageInput, sort:SortInput,filters:[FilterInput]):StatusTypeConnection
findStyleTheme(id:ID!):StyleTheme
findStyleThemeList( page: PageInput, sort:SortInput,filters:[FilterInput]):StyleThemeConnection
findTenant(id:ID!):Tenant
findTenantList( page: PageInput, sort:SortInput,filters:[FilterInput]):TenantConnection
findTranslation(id:ID!):Translation
findTranslationList( page: PageInput, sort:SortInput,filters:[FilterInput]):TranslationConnection
findType(id:ID!):Type
findTypeList( page: PageInput, sort:SortInput,filters:[FilterInput]):TypeConnection
findUser(id:ID!):User
findUserList( page: PageInput, sort:SortInput,filters:[FilterInput]):UserConnection
}
type Mutation {createWorkflow(WorkflowTo:WorkflowInput!):Workflow
modifyWorkflow(WorkflowTo:WorkflowInput!):Workflow
deleteWorkflow(idworkflow:Int!):Int
createAddress(AddressTo:AddressInput!):Address
modifyAddress(AddressTo:AddressInput!):Address
deleteAddress(idaddress:Int!):Int
createProductFunction(ProductFunctionTo:ProductFunctionInput!):ProductFunction
modifyProductFunction(ProductFunctionTo:ProductFunctionInput!):ProductFunction
deleteProductFunction(idproductfunction:Int!):Int
createAlert(AlertTo:AlertInput!):Alert
modifyAlert(AlertTo:AlertInput!):Alert
deleteAlert(idalert:Int!):Int
createAlertRule(AlertRuleTo:AlertRuleInput!):AlertRule
modifyAlertRule(AlertRuleTo:AlertRuleInput!):AlertRule
deleteAlertRule(idalertrule:Int!):Int
createAttributes(AttributesTo:AttributesInput!):Attributes
modifyAttributes(AttributesTo:AttributesInput!):Attributes
deleteAttributes(idattributes:Int!):Int
createAuditLogs(AuditLogsTo:AuditLogsInput!):AuditLogs
modifyAuditLogs(AuditLogsTo:AuditLogsInput!):AuditLogs
deleteAuditLogs(idauditlogs:Int!):Int
createCfType(CfTypeTo:CfTypeInput!):CfType
modifyCfType(CfTypeTo:CfTypeInput!):CfType
deleteCfType(idcftype:Int!):Int
createCfValue(CfValueTo:CfValueInput!):CfValue
modifyCfValue(CfValueTo:CfValueInput!):CfValue
deleteCfValue(idcfvalue:Int!):Int
createDomain(DomainTo:DomainInput!):Domain
modifyDomain(DomainTo:DomainInput!):Domain
deleteDomain(iddomain:Int!):Int
createCustomer(CustomerTo:CustomerInput!):Customer
modifyCustomer(CustomerTo:CustomerInput!):Customer
deleteCustomer(idcustomer:Int!):Int
createDelegation(DelegationTo:DelegationInput!):Delegation
modifyDelegation(DelegationTo:DelegationInput!):Delegation
deleteDelegation(iddelegation:Int!):Int
createEmailTemplate(EmailTemplateTo:EmailTemplateInput!):EmailTemplate
modifyEmailTemplate(EmailTemplateTo:EmailTemplateInput!):EmailTemplate
deleteEmailTemplate(idemailtemplate:Int!):Int
createEntityReference(EntityReferenceTo:EntityReferenceInput!):EntityReference
modifyEntityReference(EntityReferenceTo:EntityReferenceInput!):EntityReference
deleteEntityReference(identityreference:Int!):Int
createEvent(EventTo:EventInput!):Event
modifyEvent(EventTo:EventInput!):Event
deleteEvent(idevent:Int!):Int
createFormulaType(FormulaTypeTo:FormulaTypeInput!):FormulaType
modifyFormulaType(FormulaTypeTo:FormulaTypeInput!):FormulaType
deleteFormulaType(idformulatype:Int!):Int
createHtmlTag(HtmlTagTo:HtmlTagInput!):HtmlTag
modifyHtmlTag(HtmlTagTo:HtmlTagInput!):HtmlTag
deleteHtmlTag(idhtmltag:Int!):Int
createWfInstance(WfInstanceTo:WfInstanceInput!):WfInstance
modifyWfInstance(WfInstanceTo:WfInstanceInput!):WfInstance
deleteWfInstance(idwfinstance:Int!):Int
createInstance(InstanceTo:InstanceInput!):Instance
modifyInstance(InstanceTo:InstanceInput!):Instance
deleteInstance(idinstance:Int!):Int
createLanguage(LanguageTo:LanguageInput!):Language
modifyLanguage(LanguageTo:LanguageInput!):Language
deleteLanguage(idlanguage:Int!):Int
createMessage(MessageTo:MessageInput!):Message
modifyMessage(MessageTo:MessageInput!):Message
deleteMessage(idmessage:Int!):Int
createProduct(ProductTo:ProductInput!):Product
modifyProduct(ProductTo:ProductInput!):Product
deleteProduct(idproduct:Int!):Int
createNode(NodeTo:NodeInput!):Node
modifyNode(NodeTo:NodeInput!):Node
deleteNode(idnode:Int!):Int
createNodeCf(NodeCfTo:NodeCfInput!):NodeCf
modifyNodeCf(NodeCfTo:NodeCfInput!):NodeCf
deleteNodeCf(idnodecf:Int!):Int
createNumberSequenceRule(NumberSequenceRuleTo:NumberSequenceRuleInput!):NumberSequenceRule
modifyNumberSequenceRule(NumberSequenceRuleTo:NumberSequenceRuleInput!):NumberSequenceRule
deleteNumberSequenceRule(idnumbersequencerule:Int!):Int
createNumberSequenceRuleSegment(NumberSequenceRuleSegmentTo:NumberSequenceRuleSegmentInput!):NumberSequenceRuleSegment
modifyNumberSequenceRuleSegment(NumberSequenceRuleSegmentTo:NumberSequenceRuleSegmentInput!):NumberSequenceRuleSegment
deleteNumberSequenceRuleSegment(idnumbersequencerulesegment:Int!):Int
createOrganization(OrganizationTo:OrganizationInput!):Organization
modifyOrganization(OrganizationTo:OrganizationInput!):Organization
deleteOrganization(idorganization:Int!):Int
createPerson(PersonTo:PersonInput!):Person
modifyPerson(PersonTo:PersonInput!):Person
deletePerson(idperson:Int!):Int
createPersonStatus(PersonStatusTo:PersonStatusInput!):PersonStatus
modifyPersonStatus(PersonStatusTo:PersonStatusInput!):PersonStatus
deletePersonStatus(idpersonstatus:Int!):Int
createPhase(PhaseTo:PhaseInput!):Phase
modifyPhase(PhaseTo:PhaseInput!):Phase
deletePhase(idphase:Int!):Int
createPreference(PreferenceTo:PreferenceInput!):Preference
modifyPreference(PreferenceTo:PreferenceInput!):Preference
deletePreference(idpreference:Int!):Int
createProcess(ProcessTo:ProcessInput!):Process
modifyProcess(ProcessTo:ProcessInput!):Process
deleteProcess(idprocess:Int!):Int
createRequest(RequestTo:RequestInput!):Request
modifyRequest(RequestTo:RequestInput!):Request
deleteRequest(idrequest:Int!):Int
createRole(RoleTo:RoleInput!):Role
modifyRole(RoleTo:RoleInput!):Role
deleteRole(idrole:Int!):Int
createSegment(SegmentTo:SegmentInput!):Segment
modifySegment(SegmentTo:SegmentInput!):Segment
deleteSegment(idsegment:Int!):Int
createStage(StageTo:StageInput!):Stage
modifyStage(StageTo:StageInput!):Stage
deleteStage(idstage:Int!):Int
createStatus(StatusTo:StatusInput!):Status
modifyStatus(StatusTo:StatusInput!):Status
deleteStatus(idstatus:Int!):Int
createStatusType(StatusTypeTo:StatusTypeInput!):StatusType
modifyStatusType(StatusTypeTo:StatusTypeInput!):StatusType
deleteStatusType(idstatustype:Int!):Int
createStyleTheme(StyleThemeTo:StyleThemeInput!):StyleTheme
modifyStyleTheme(StyleThemeTo:StyleThemeInput!):StyleTheme
deleteStyleTheme(idstyletheme:Int!):Int
createTenant(TenantTo:TenantInput!):Tenant
modifyTenant(TenantTo:TenantInput!):Tenant
deleteTenant(idtenant:Int!):Int
createTranslation(TranslationTo:TranslationInput!):Translation
modifyTranslation(TranslationTo:TranslationInput!):Translation
deleteTranslation(idtranslation:Int!):Int
createType(TypeTo:TypeInput!):Type
modifyType(TypeTo:TypeInput!):Type
deleteType(idtype:Int!):Int
createUser(UserTo:UserInput!):User
modifyUser(UserTo:UserInput!):User
deleteUser(iduser:Int!):Int
}

type WorkflowConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Workflow]
}
#Define the different workflow that interact with the processes.
type Workflow {
#Title/Short name of the workflow
title: String
#Full name of the workflow
name: String
#Additional information about the workflow
description: String
#Additional helpful Information about the workflow
help: String
#Consecutive number within specific workflow
sortNo: Int
#Definition of the workflow
definition: String
#Icon displayed in the side bar.
icon: String
id: ID!
phases:[Phase]
entityreference:EntityReference
tenant:Tenant
htmltag:HtmlTag
wfinstances:[WfInstance]
nodes:[Node]
node:Node
}
type AddressConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Address]
}
#Stores the physical address of users, clients, persons.
type Address {
#Location of the address
location: String
#Region of the address
region: String
#Zip code
zipCode: String
#Street name
streetAddress: String
tenant: Int
id: ID!
persons:[Person]
}
type ProductFunctionConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [ProductFunction]
}
#Stores specific actions of the different modules of the system.
type ProductFunction {
#description/Additional information about the action.
description: String
#Type of the action, it can be a human task or a system action.
systemType: Boolean
#Name of the action, it can be an option module. e.g. Request module action: Create request.
action: String
tenant: Int
id: ID!
stage:Stage
node:Node
roles:[Role]
product:Product
}
type AlertConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Alert]
}
#Management of the user alerts set to users.
type Alert {
#Description of the alert.
description: String
tenant: Int
id: ID!
alertrules:[AlertRule]
htmltag:HtmlTag
preferences:[Preference]
}
type AlertRuleConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [AlertRule]
}
#Manages the alert rules and how they are created.
type AlertRule {
#Name of the rule.
name: String
#Sentence to be executed to verify if the user has alerts.
sql: String
#Filter applied in the select statement.
filterClause: String
tenant: Int
id: ID!
alert:Alert
}
type AttributesConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Attributes]
}
#Contains all the attributes of the database tables.
type Attributes {
#Name od the attribute.
name: String
#Description of the attribute
description: String
#Additional information about the attribute.
help: String
#sort number of the attribute within its table.
sortNo: Int
#Specifies the component of material UI.
attComponent: String
#Specifies if the field is a long text.
isMultiline: Boolean
#Determine if the attribute is required or not.
isRequired: Boolean
#Specifies if the attribute has a default value.
defaultValue: String
#Small size grids use columns that scale and resize content
sm: Int
#Medium size grids use columns that scale and resize content
md: Int
#Large size grids use columns that scale and resize content
lg: Int
id: ID!
entityreference:EntityReference
htmltag:HtmlTag
}
type AuditLogsConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [AuditLogs]
}
#Register events of the users, applications and components of the tenant.
type AuditLogs {
#Identifier of the log of a specific component.
correlationId: String
#Message of the log.
message: String
tenant: Int
id: ID!
instance:Instance
}
type CfTypeConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [CfType]
}
#Manages the different types of the custom fields, they can be, string, int, boolean, etc.
type CfType {
#Name of the custom field type
name: String
#Description of the custom field type.
description: String
#Additional information about the custom field type.
help: String
#Type of the custom field.
type: String
tenant: Int
id: ID!
nodecfs:[NodeCf]
}
type CfValueConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [CfValue]
}
#Stores the actual values of the different custom fields.
type CfValue {
#If the custom field is a flag, the value will be stored in this column.
flagValue: Boolean
#If the custom field is a string,  the value will be stored in this column.

textValue: String
#If the custom field is a number,  the value will be stored in this column.
numValue: Int
#If the custom field is a date type,  the value will be stored in this column.

dateValue: Date
#If the custom field is a code, the value will be stored in this column.
codeValue: Int
tenant: Int
id: ID!
request:Request
nodecf:NodeCf
}
type DomainConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Domain]
}
#Registers all components or microservices available for the user
type Domain {
#Name of the component.
name: String
#Version of the component.
version: String
#Latest stable release number.
releaseNo: String
#Additional information about the component.
info: String
#Icon displayed in the side bar.
icon: String
#Port of the server where the source database is installed
port: String
#Host of the server where the source database is installed.
host: String
tenant: Int
id: ID!
instances:[Instance]
entityreferences:[EntityReference]
htmltag:HtmlTag
products:[Product]
}
type CustomerConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Customer]
}
#Registered client of the application, that client can be a individual or a company
type Customer {
#Name of the customer
name: String
#Phone number of the customer
phone: String
#Institution/Official email of the customer
officialEmail: String
#Additional email of the customer
alternateEmail: String
#Job title/ Position of the customer within his/her institution
jobTitle: String
#Preferred language to display system option
languagePreference: String
#Extension number of the customer within his/her Organization.
phoneExtension: String
#Status of the customer, it can be active or not.
isActive: String
id: ID!
organizations:[Organization]
organization:Organization
tenants:[Tenant]
}
type DelegationConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Delegation]
}
#Stores delegation information when a users assign certain privileges to a member of his team.
type Delegation {
#Date when the delegation of activities starts.
startDate: Date
#Date when the delegation of activities is over.
endDate: Date
#Person to whom the activities were delegated.
delegateTo: String
tenant: Int
id: ID!
user:User
}
type EmailTemplateConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [EmailTemplate]
}
#Stores the different email templates of the system.
type EmailTemplate {
#Name of the email template
name: String
#Subject of the email template.
subject: String
#COntent of the template
template: String
id: ID!
entityreferences:[EntityReference]
tenant:Tenant
person:Person
}
type EntityReferenceConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [EntityReference]
}
#Stores all the existing entities/tables of the system.
type EntityReference {
#Name of the entity.
entity: String
#Main column name of the entity.
textfield: String
#Column used to get the register number (id)
valuefield: String
#
storefield: String
#Schema where the entity belongs to.
entitySchema: String
tenant: Int
id: ID!
attributess:[Attributes]
emailtemplates:[EmailTemplate]
domains:[Domain]
workflows:[Workflow]
segments:[Segment]
nodes:[Node]
numbersequencerules:[NumberSequenceRule]
nodecfs:[NodeCf]
}
type EventConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Event]
}
#Manages the workflow events.
type Event {
#Specifies if the event is completed.
completed: Date
#Shows the error description in case there was a problem during the event execution.
error: String
#Description of the Workflow event.
description: String
tenant: Int
id: ID!
stage:Stage
wfinstance:WfInstance
node:Node
}
type FormulaTypeConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [FormulaType]
}
#
type FormulaType {
#
name: String
#
description: String
tenant: Int
id: ID!
segments:[Segment]
}
type HtmlTagConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [HtmlTag]
}
#Stores the html tags of each concept of the system.
type HtmlTag {
#Name of the tag.
tagName: String
id: ID!
attributess:[Attributes]
messages:[Message]
domains:[Domain]
workflows:[Workflow]
phases:[Phase]
alerts:[Alert]
stages:[Stage]
translations:[Translation]
nodes:[Node]
products:[Product]
nodecfs:[NodeCf]
}
type WfInstanceConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [WfInstance]
}
#Manages the instances of the workflow.
type WfInstance {
#Date time when the instance is completed.
complete: Date
#Date time when the instance is initiated. 
initiated: Date
tenant: Int
id: ID!
statuss:[Status]
events:[Event]
workflow:Workflow
requests:[Request]
}
type InstanceConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Instance]
}
#instance management of all services liked with the client
type Instance {
#
server: String
#
port: String
#
health: String
id: ID!
auditlogss:[AuditLogs]
domains:[Domain]
tenant:Tenant
}
type LanguageConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Language]
}
#Manages the globalization of the application
type Language {
#Language name
name: String
#Unique code identifier of the language.
codeISO: String
#Determines if the language is base or not.
isBase: String
id: ID!
translations:[Translation]
persons:[Person]
}
type MessageConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Message]
}
#Manages the text message that the user receives from the  application.
type Message {
#Description of the message.
description: String
#sql script
sql: String
#Filter clause
filterClause: String
id: ID!
htmltag:HtmlTag
}
type ProductConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Product]
}
#Stores the menu of each component or service. It depends on the registered components.
type Product {
#Name of the module.
name: String
#Description or additional information of the module.
description: String
#Additional information about the module.
help: String
#url/Path  of the Module.
route: String
#Principal entity of each module, e.g. Module:Sample Manager; Main entity: Sample.
mainEntity: String
#Icon displayed in the side bar.
icon: String
#Name of the docker container of the module.
container: String
tenant: Int
id: ID!
productfunctions:[ProductFunction]
domain:Domain
htmltag:HtmlTag
nodes:[Node]
}
type NodeConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Node]
}
#Manages the workflow nodes.
type Node {
#Name of the workflow node
name: String
#Description of the workflow node.
description: String
#Additional information about the node.
help: String
#Sequential number of the node within the workflow.
sequence: Int
#Specifies if the process of the node requires any type of approval.
requireApproval: Boolean
tenant: Int
id: ID!
stages:[Stage]
workflow:Workflow
productfunctions:[ProductFunction]
entityreference:EntityReference
events:[Event]
htmltag:HtmlTag
workflows:[Workflow]
process:Process
product:Product
nodecfs:[NodeCf]
}
type NodeCfConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [NodeCf]
}
#Stores the names of the custom fields.
type NodeCf {
#Name of the custom field.
name: String
#Description of the custom field.
description: String
#Additional information about the custom field.
help: String
#Specifies id the custom field is required or not.
required: Boolean
tenant: Int
id: ID!
cfvalues:[CfValue]
cftype:CfType
htmltag:HtmlTag
entityreference:EntityReference
node:Node
}
type NumberSequenceRuleConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [NumberSequenceRule]
}
#Stores all the different rules used to generate string codes.
type NumberSequenceRule {
#Name of the rule.
name: String
#Specifies the initial sequential number.
lowest: Int
#The last code plus one to create the next sequential number.
nextRec: Int
#Format of the string code.
format: String
#Shows the last number generated by the rule.
lastCode: String
id: ID!
numbersequencerulesegments:[NumberSequenceRuleSegment]
tenant:Tenant
entityreferences:[EntityReference]
}
type NumberSequenceRuleSegmentConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [NumberSequenceRuleSegment]
}
#Contains the relation between the rule and the segments used to create a particular code.
type NumberSequenceRuleSegment {
#Length of the segment part od the code.
length: Int
#Field that affects the origin of the sequence.
customField: String
#Position of the segment within the code.
position: Int
#Formula applied in the segment to get the required data.
formula: String
tenant: Int
id: ID!
segment:Segment
numbersequencerule:NumberSequenceRule
}
type OrganizationConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Organization]
}
#Stores all the information of the different Organizations related to the system.
type Organization {
#Official name of the Organization.
legalName: String
#Official phone number of the organization.

phone: String
#Official web site of the Organization.
webPage: String
#Slogan of the Organization.
slogan: String
#Short name of the organization.
name: String
#Tax ID of the Organization.
taxID: String
#Logo of the Organization.
logo: String
#Specifies the status of the Organization within the system, it can be active or not.
isActive: String
#Type of authentication used to login into the System.
defaultAuthentication: Int
#Default theme preferred by the Organization
defaultTheme: Int
#Unique identifier code for the Organization.
code: Int
id: ID!
tenants:[Tenant]
customer:Customer
customers:[Customer]
}
type PersonConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Person]
}
#Stores the information of individuals that are part or are related to the System.
type Person {
#First name of the person
familyName: String
#Last name of the person.
givenName: String
#Second name of the person if its the case.
additionalName: String
#Additional email of the person different that the official.
email: String
#Official or institutional email of the person.
officialEmail: String
#Gender of the person. Male/Female.
gender: String
#Specifies if the person has or not credentials in the System.
hasCredential: Boolean
#Position or job title of the person.
jobTitle: String
#Expertise of the person.
knowsAbout: String
#Phone number of the person.
phone: String
id: ID!
requests:[Request]
addresss:[Address]
tenant:Tenant
types:[Type]
language:Language
emailtemplates:[EmailTemplate]
users:[User]
personstatus:PersonStatus
}
type PersonStatusConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [PersonStatus]
}
#
type PersonStatus {
#
name: String
#
description: String
tenant: Int
id: ID!
persons:[Person]
}
type PhaseConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Phase]
}
#Manages the different phases of the different workflows.
type Phase {
#Name of the workflow phase.
name: String
#Description of the workflow phase.
description: String
#Additional information about the workflow phase.
help: String
#Sequential number of the phases within the corresponding node.
sequence: Int
tenant: Int
id: ID!
stages:[Stage]
workflow:Workflow
htmltag:HtmlTag
}
type PreferenceConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Preference]
}
#Stores the preferences of the user: style, language, etc.
type Preference {
#User comments about the system.
comment: String
tenant: Int
id: ID!
user:User
alert:Alert
styletheme:StyleTheme
}
type ProcessConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Process]
}
#Register all process that can be executed by any component or workflow.
type Process {
#Name of the process. e.g. import germplasm.
name: String
#Additional information about the process.
description: String
#Javascript Code to be executed when isBackground = false
code: String
#Specifies if the process exists in the EBS sg.
isBackground: Boolean
#DB function to be executed when isBackground = true.
dbFunction: String
#Specific report to call when tisBackground = true.
callReport: Boolean
#url, path where the process is located.
path: String
tenant: Int
id: ID!
nodes:[Node]
}
type RequestConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Request]
}
#Stores all the requests made for different services to different units.
type Request {
#Id of the person who is making a request
requester: String
#Unique code identifier of the request
requestCode: String
#Date when the request is submitted 
submitionDate: Date
#Refers to the admin person to contact about the request.
adminContact: String
#Account to charge the cost of the service.
chargeAccount: String
#Additional information about the request
description: String
tenant: Int
id: ID!
cfvalues:[CfValue]
wfinstance:WfInstance
person:Person
}
type RoleConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Role]
}
#Manages the different positions or purposes that someone has in an , organization as well as the set of privileges granted.
type Role {
#Description of the role.
description: String
#Security group where user belongs to.
securityGroup: String
tenant: Int
id: ID!
productfunctions:[ProductFunction]
users:[User]
}
type SegmentConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Segment]
}
#Manages the sections of the codes used in the sequence rules.
type Segment {
#Descriptive name of the segment.
name: String
#Short name identifier of the segment.
tag: String
#Specifies if the segment is obtained by calling an API.
isAPI: Boolean
#Specifies if the segment is an sequence number value.
isAutoNum: Boolean
#Specifies if the segment is an static value such as prefix, separator symbol, etc.
isStatic: Boolean
tenant: Int
id: ID!
entityreference:EntityReference
numbersequencerulesegments:[NumberSequenceRuleSegment]
formulatype:FormulaType
}
type StageConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Stage]
}
#Manages the stages of the different workflow phases.
type Stage {
#Name of the workflow stage.
name: String
#Description of the workflow stage.
description: String
#Additional information about the stage.
help: String
#Sequential number of the stages within the phase.
sequence: Int
#
parentId: Int
tenant: Int
id: ID!
productfunctions:[ProductFunction]
phase:Phase
events:[Event]
htmltag:HtmlTag
nodes:[Node]
}
type StatusConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Status]
}
#Manages the different statuses used in the Workflow engine.
type Status {
#Date when the workflow was initiated.
initiateDate: Date
#Date when the workflow was completed.
completionDate: Date
tenant: Int
id: ID!
statustype:StatusType
wfinstance:WfInstance
}
type StatusTypeConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [StatusType]
}
#Manages the statuses type of the workflow engine.
type StatusType {
#Name of the status type.
name: String
#Description of the status type.
description: String
#Additional information about status type.
help: String
tenant: Int
id: ID!
statuss:[Status]
}
type StyleThemeConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [StyleTheme]
}
#Manages the different styles them used in the system.
type StyleTheme {
#Description of the theme.
description: String
#Physical path were the theme is stored.
path: String
#Full name of the Style theme.
physicalName: String
#Specifies if the theme is the default one to use in the system.
defaulta: Boolean
tenant: Int
id: ID!
preferences:[Preference]
}
type TenantConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Tenant]
}
#Manages EBS Instance by customer and organization.
type Tenant {
#
name: String
#Expiration date of the instance by user.
expiration: Date
#Specifies if the tenant instance is expired or not.
expired: Boolean
id: ID!
emailtemplates:[EmailTemplate]
users:[User]
instances:[Instance]
workflows:[Workflow]
organization:Organization
numbersequencerules:[NumberSequenceRule]
customer:Customer
persons:[Person]
}
type TranslationConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Translation]
}
#Manages the translation options of the system.
type Translation {
#Sentence or word translated.
translation: String
#Language of the translation.
languageTo: Int
id: ID!
language:Language
htmltag:HtmlTag
}
type TypeConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [Type]
}
#Stores all the person defined as collaborators certain projects.
type Type {
#Institution/Organization where the collaborator belongs to.
type: String
#Person to contact who represents the donor.
contactPoint: String
#Unique code identifier of the collaborator.
remarks: String
tenant: Int
id: ID!
persons:[Person]
}
type UserConnection {
totalPages: Int
totalElements: Int
numberOfElements: Int
size: Int
number: Int
content: [User]
}
#User management 
type User {
#Name of the ser
userName: String
#Date of the latest access of the user.
lastAccess: Date
#
userPassword: String
#Default role of the user
defaultRole: Int
#Specifies if its IS or not.
isIS: Int
id: ID!
delegations:[Delegation]
tenant:Tenant
preferences:[Preference]
roles:[Role]
person:Person
}

input WorkflowInput {
#Title/Short name of the workflow
title: String
#Full name of the workflow
name: String
#Additional information about the workflow
description: String
#Additional helpful Information about the workflow
help: String
#Consecutive number within specific workflow
sortNo: Int
#Definition of the workflow
definition: String
#Icon displayed in the side bar.
icon: String
id: ID!
entityreference:EntityReferenceInput
tenant:TenantInput
htmltag:HtmlTagInput
node:NodeInput
}
input AddressInput {
#Location of the address
location: String
#Region of the address
region: String
#Zip code
zipCode: String
#Street name
streetAddress: String
tenant: Int
id: ID!
}
input ProductFunctionInput {
#description/Additional information about the action.
description: String
#Type of the action, it can be a human task or a system action.
systemType: Boolean
#Name of the action, it can be an option module. e.g. Request module action: Create request.
action: String
tenant: Int
id: ID!
stage:StageInput
node:NodeInput
roles:[RoleInput]
product:ProductInput
}
input AlertInput {
#Description of the alert.
description: String
tenant: Int
id: ID!
htmltag:HtmlTagInput
}
input AlertRuleInput {
#Name of the rule.
name: String
#Sentence to be executed to verify if the user has alerts.
sql: String
#Filter applied in the select statement.
filterClause: String
tenant: Int
id: ID!
alert:AlertInput
}
input AttributesInput {
#Name od the attribute.
name: String
#Description of the attribute
description: String
#Additional information about the attribute.
help: String
#sort number of the attribute within its table.
sortNo: Int
#Specifies the component of material UI.
attComponent: String
#Specifies if the field is a long text.
isMultiline: Boolean
#Determine if the attribute is required or not.
isRequired: Boolean
#Specifies if the attribute has a default value.
defaultValue: String
#Small size grids use columns that scale and resize content
sm: Int
#Medium size grids use columns that scale and resize content
md: Int
#Large size grids use columns that scale and resize content
lg: Int
id: ID!
entityreference:EntityReferenceInput
htmltag:HtmlTagInput
}
input AuditLogsInput {
#Identifier of the log of a specific component.
correlationId: String
#Message of the log.
message: String
tenant: Int
id: ID!
instance:InstanceInput
}
input CfTypeInput {
#Name of the custom field type
name: String
#Description of the custom field type.
description: String
#Additional information about the custom field type.
help: String
#Type of the custom field.
type: String
tenant: Int
id: ID!
}
input CfValueInput {
#If the custom field is a flag, the value will be stored in this column.
flagValue: Boolean
#If the custom field is a string,  the value will be stored in this column.

textValue: String
#If the custom field is a number,  the value will be stored in this column.
numValue: Int
#If the custom field is a date type,  the value will be stored in this column.

dateValue: Date
#If the custom field is a code, the value will be stored in this column.
codeValue: Int
tenant: Int
id: ID!
request:RequestInput
nodecf:NodeCfInput
}
input DomainInput {
#Name of the component.
name: String
#Version of the component.
version: String
#Latest stable release number.
releaseNo: String
#Additional information about the component.
info: String
#Icon displayed in the side bar.
icon: String
#Port of the server where the source database is installed
port: String
#Host of the server where the source database is installed.
host: String
tenant: Int
id: ID!
htmltag:HtmlTagInput
}
input CustomerInput {
#Name of the customer
name: String
#Phone number of the customer
phone: String
#Institution/Official email of the customer
officialEmail: String
#Additional email of the customer
alternateEmail: String
#Job title/ Position of the customer within his/her institution
jobTitle: String
#Preferred language to display system option
languagePreference: String
#Extension number of the customer within his/her Organization.
phoneExtension: String
#Status of the customer, it can be active or not.
isActive: String
id: ID!
organization:OrganizationInput
}
input DelegationInput {
#Date when the delegation of activities starts.
startDate: Date
#Date when the delegation of activities is over.
endDate: Date
#Person to whom the activities were delegated.
delegateTo: String
tenant: Int
id: ID!
user:UserInput
}
input EmailTemplateInput {
#Name of the email template
name: String
#Subject of the email template.
subject: String
#COntent of the template
template: String
id: ID!
tenant:TenantInput
person:PersonInput
}
input EntityReferenceInput {
#Name of the entity.
entity: String
#Main column name of the entity.
textfield: String
#Column used to get the register number (id)
valuefield: String
#
storefield: String
#Schema where the entity belongs to.
entitySchema: String
tenant: Int
id: ID!
emailtemplates:[EmailTemplateInput]
domains:[DomainInput]
numbersequencerules:[NumberSequenceRuleInput]
}
input EventInput {
#Specifies if the event is completed.
completed: Date
#Shows the error description in case there was a problem during the event execution.
error: String
#Description of the Workflow event.
description: String
tenant: Int
id: ID!
stage:StageInput
wfinstance:WfInstanceInput
node:NodeInput
}
input FormulaTypeInput {
#
name: String
#
description: String
tenant: Int
id: ID!
}
input HtmlTagInput {
#Name of the tag.
tagName: String
id: ID!
}
input WfInstanceInput {
#Date time when the instance is completed.
complete: Date
#Date time when the instance is initiated. 
initiated: Date
tenant: Int
id: ID!
workflow:WorkflowInput
}
input InstanceInput {
#
server: String
#
port: String
#
health: String
id: ID!
domains:[DomainInput]
tenant:TenantInput
}
input LanguageInput {
#Language name
name: String
#Unique code identifier of the language.
codeISO: String
#Determines if the language is base or not.
isBase: String
id: ID!
}
input MessageInput {
#Description of the message.
description: String
#sql script
sql: String
#Filter clause
filterClause: String
id: ID!
htmltag:HtmlTagInput
}
input ProductInput {
#Name of the module.
name: String
#Description or additional information of the module.
description: String
#Additional information about the module.
help: String
#url/Path  of the Module.
route: String
#Principal entity of each module, e.g. Module:Sample Manager; Main entity: Sample.
mainEntity: String
#Icon displayed in the side bar.
icon: String
#Name of the docker container of the module.
container: String
tenant: Int
id: ID!
domain:DomainInput
htmltag:HtmlTagInput
}
input NodeInput {
#Name of the workflow node
name: String
#Description of the workflow node.
description: String
#Additional information about the node.
help: String
#Sequential number of the node within the workflow.
sequence: Int
#Specifies if the process of the node requires any type of approval.
requireApproval: Boolean
tenant: Int
id: ID!
workflow:WorkflowInput
entityreference:EntityReferenceInput
htmltag:HtmlTagInput
process:ProcessInput
product:ProductInput
}
input NodeCfInput {
#Name of the custom field.
name: String
#Description of the custom field.
description: String
#Additional information about the custom field.
help: String
#Specifies id the custom field is required or not.
required: Boolean
tenant: Int
id: ID!
cftype:CfTypeInput
htmltag:HtmlTagInput
entityreference:EntityReferenceInput
node:NodeInput
}
input NumberSequenceRuleInput {
#Name of the rule.
name: String
#Specifies the initial sequential number.
lowest: Int
#The last code plus one to create the next sequential number.
nextRec: Int
#Format of the string code.
format: String
#Shows the last number generated by the rule.
lastCode: String
id: ID!
tenant:TenantInput
}
input NumberSequenceRuleSegmentInput {
#Length of the segment part od the code.
length: Int
#Field that affects the origin of the sequence.
customField: String
#Position of the segment within the code.
position: Int
#Formula applied in the segment to get the required data.
formula: String
tenant: Int
id: ID!
segment:SegmentInput
numbersequencerule:NumberSequenceRuleInput
}
input OrganizationInput {
#Official name of the Organization.
legalName: String
#Official phone number of the organization.

phone: String
#Official web site of the Organization.
webPage: String
#Slogan of the Organization.
slogan: String
#Short name of the organization.
name: String
#Tax ID of the Organization.
taxID: String
#Logo of the Organization.
logo: String
#Specifies the status of the Organization within the system, it can be active or not.
isActive: String
#Type of authentication used to login into the System.
defaultAuthentication: Int
#Default theme preferred by the Organization
defaultTheme: Int
#Unique identifier code for the Organization.
code: Int
id: ID!
customer:CustomerInput
}
input PersonInput {
#First name of the person
familyName: String
#Last name of the person.
givenName: String
#Second name of the person if its the case.
additionalName: String
#Additional email of the person different that the official.
email: String
#Official or institutional email of the person.
officialEmail: String
#Gender of the person. Male/Female.
gender: String
#Specifies if the person has or not credentials in the System.
hasCredential: Boolean
#Position or job title of the person.
jobTitle: String
#Expertise of the person.
knowsAbout: String
#Phone number of the person.
phone: String
id: ID!
addresss:[AddressInput]
tenant:TenantInput
language:LanguageInput
personstatus:PersonStatusInput
}
input PersonStatusInput {
#
name: String
#
description: String
tenant: Int
id: ID!
}
input PhaseInput {
#Name of the workflow phase.
name: String
#Description of the workflow phase.
description: String
#Additional information about the workflow phase.
help: String
#Sequential number of the phases within the corresponding node.
sequence: Int
tenant: Int
id: ID!
workflow:WorkflowInput
htmltag:HtmlTagInput
}
input PreferenceInput {
#User comments about the system.
comment: String
tenant: Int
id: ID!
user:UserInput
alert:AlertInput
styletheme:StyleThemeInput
}
input ProcessInput {
#Name of the process. e.g. import germplasm.
name: String
#Additional information about the process.
description: String
#Javascript Code to be executed when isBackground = false
code: String
#Specifies if the process exists in the EBS sg.
isBackground: Boolean
#DB function to be executed when isBackground = true.
dbFunction: String
#Specific report to call when tisBackground = true.
callReport: Boolean
#url, path where the process is located.
path: String
tenant: Int
id: ID!
}
input RequestInput {
#Id of the person who is making a request
requester: String
#Unique code identifier of the request
requestCode: String
#Date when the request is submitted 
submitionDate: Date
#Refers to the admin person to contact about the request.
adminContact: String
#Account to charge the cost of the service.
chargeAccount: String
#Additional information about the request
description: String
tenant: Int
id: ID!
wfinstance:WfInstanceInput
person:PersonInput
}
input RoleInput {
#Description of the role.
description: String
#Security group where user belongs to.
securityGroup: String
tenant: Int
id: ID!
users:[UserInput]
}
input SegmentInput {
#Descriptive name of the segment.
name: String
#Short name identifier of the segment.
tag: String
#Specifies if the segment is obtained by calling an API.
isAPI: Boolean
#Specifies if the segment is an sequence number value.
isAutoNum: Boolean
#Specifies if the segment is an static value such as prefix, separator symbol, etc.
isStatic: Boolean
tenant: Int
id: ID!
entityreference:EntityReferenceInput
formulatype:FormulaTypeInput
}
input StageInput {
#Name of the workflow stage.
name: String
#Description of the workflow stage.
description: String
#Additional information about the stage.
help: String
#Sequential number of the stages within the phase.
sequence: Int
#
parentId: Int
tenant: Int
id: ID!
phase:PhaseInput
htmltag:HtmlTagInput
nodes:[NodeInput]
}
input StatusInput {
#Date when the workflow was initiated.
initiateDate: Date
#Date when the workflow was completed.
completionDate: Date
tenant: Int
id: ID!
statustype:StatusTypeInput
wfinstance:WfInstanceInput
}
input StatusTypeInput {
#Name of the status type.
name: String
#Description of the status type.
description: String
#Additional information about status type.
help: String
tenant: Int
id: ID!
}
input StyleThemeInput {
#Description of the theme.
description: String
#Physical path were the theme is stored.
path: String
#Full name of the Style theme.
physicalName: String
#Specifies if the theme is the default one to use in the system.
defaulta: Boolean
tenant: Int
id: ID!
}
input TenantInput {
#
name: String
#Expiration date of the instance by user.
expiration: Date
#Specifies if the tenant instance is expired or not.
expired: Boolean
id: ID!
organization:OrganizationInput
customer:CustomerInput
}
input TranslationInput {
#Sentence or word translated.
translation: String
#Language of the translation.
languageTo: Int
id: ID!
language:LanguageInput
htmltag:HtmlTagInput
}
input TypeInput {
#Institution/Organization where the collaborator belongs to.
type: String
#Person to contact who represents the donor.
contactPoint: String
#Unique code identifier of the collaborator.
remarks: String
tenant: Int
id: ID!
persons:[PersonInput]
}
input UserInput {
#Name of the ser
userName: String
#Date of the latest access of the user.
lastAccess: Date
#
userPassword: String
#Default role of the user
defaultRole: Int
#Specifies if its IS or not.
isIS: Int
id: ID!
tenant:TenantInput
person:PersonInput
}

input FilterInput { 
mod: FilterMod = EQ
col: String!
val: String!
}

input SortInput {
col: String!
mod: SortMod = ASC
}

input PageInput {
number: Int! = 0
size: Int!=1
}

enum FilterMod {
EQ
LK
}

enum SortMod {
ASC
DES
}

scalar Date

